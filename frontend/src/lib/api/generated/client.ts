/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * Simple Note Application API
 * A simple note-taking application API that allows anonymous browsing of latest public notes 
and authenticated access to personal plain text notebook features.

## Authentication
- Public endpoints require no authentication
- Private endpoints use Firebase Auth with session cookies
- Anonymous users are automatically created for notebook access
- Regular users can access basic profile management features

 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AnonymousAuthRequest,
  AuthResponse,
  CreateNoteRequest,
  ErrorResponse,
  GetUserNotesParams,
  ListPublicNotesParams,
  LoginRequest,
  NoteListResponse,
  NoteResponse,
  PrivateNoteListResponse,
  PrivateNoteResponse,
  PromoteRequest,
  SessionResponse,
  SignupRequest,
  UpdateNoteRequest,
  UpdateUserProfileRequest,
  UserProfileResponse
} from './schemas';

import { customFetch } from '../customFetch';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Get a paginated list of latest public notes in chronological order
 * @summary List latest public notes
 */
export const getListPublicNotesUrl = (params?: ListPublicNotesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/notes?${stringifiedParams}` : `/notes`
}

export const listPublicNotes = async (params?: ListPublicNotesParams, options?: RequestInit): Promise<NoteListResponse> => {
  
  return customFetch<NoteListResponse>(getListPublicNotesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getListPublicNotesQueryKey = (params?: ListPublicNotesParams,) => {
    return [`/notes`, ...(params ? [params]: [])] as const;
    }

    
export const getListPublicNotesQueryOptions = <TData = Awaited<ReturnType<typeof listPublicNotes>>, TError = ErrorResponse>(params?: ListPublicNotesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listPublicNotes>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPublicNotesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPublicNotes>>> = ({ signal }) => listPublicNotes(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPublicNotes>>, TError, TData> & { queryKey: QueryKey }
}

export type ListPublicNotesQueryResult = NonNullable<Awaited<ReturnType<typeof listPublicNotes>>>
export type ListPublicNotesQueryError = ErrorResponse


/**
 * @summary List latest public notes
 */

export function useListPublicNotes<TData = Awaited<ReturnType<typeof listPublicNotes>>, TError = ErrorResponse>(
 params?: ListPublicNotesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listPublicNotes>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListPublicNotesQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a specific public note by its UUID
 * @summary Get public note by ID
 */
export const getGetPublicNoteUrl = (id: string,) => {


  

  return `/notes/${id}`
}

export const getPublicNote = async (id: string, options?: RequestInit): Promise<NoteResponse> => {
  
  return customFetch<NoteResponse>(getGetPublicNoteUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetPublicNoteQueryKey = (id?: string,) => {
    return [`/notes/${id}`] as const;
    }

    
export const getGetPublicNoteQueryOptions = <TData = Awaited<ReturnType<typeof getPublicNote>>, TError = ErrorResponse>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getPublicNote>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPublicNoteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublicNote>>> = ({ signal }) => getPublicNote(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPublicNote>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPublicNoteQueryResult = NonNullable<Awaited<ReturnType<typeof getPublicNote>>>
export type GetPublicNoteQueryError = ErrorResponse


/**
 * @summary Get public note by ID
 */

export function useGetPublicNote<TData = Awaited<ReturnType<typeof getPublicNote>>, TError = ErrorResponse>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getPublicNote>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetPublicNoteQueryOptions(id,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get user's private plain text notes in their personal notebook.
If user is not authenticated, this will automatically create an anonymous user and register them in the database.

 * @summary List user's private notes
 */
export const getGetUserNotesUrl = (params?: GetUserNotesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/me/notes?${stringifiedParams}` : `/me/notes`
}

export const getUserNotes = async (params?: GetUserNotesParams, options?: RequestInit): Promise<PrivateNoteListResponse> => {
  
  return customFetch<PrivateNoteListResponse>(getGetUserNotesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetUserNotesQueryKey = (params?: GetUserNotesParams,) => {
    return [`/me/notes`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUserNotesQueryOptions = <TData = Awaited<ReturnType<typeof getUserNotes>>, TError = ErrorResponse>(params?: GetUserNotesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserNotes>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserNotesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserNotes>>> = ({ signal }) => getUserNotes(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserNotes>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserNotesQueryResult = NonNullable<Awaited<ReturnType<typeof getUserNotes>>>
export type GetUserNotesQueryError = ErrorResponse


/**
 * @summary List user's private notes
 */

export function useGetUserNotes<TData = Awaited<ReturnType<typeof getUserNotes>>, TError = ErrorResponse>(
 params?: GetUserNotesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserNotes>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUserNotesQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new private plain text note.
If user is anonymous and not yet registered in database, they will be automatically registered.

 * @summary Create new private note
 */
export const getCreateUserNoteUrl = () => {


  

  return `/me/notes`
}

export const createUserNote = async (createNoteRequest: CreateNoteRequest, options?: RequestInit): Promise<PrivateNoteResponse> => {
  
  return customFetch<PrivateNoteResponse>(getCreateUserNoteUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createNoteRequest,)
  }
);}




export const getCreateUserNoteMutationOptions = <TError = ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUserNote>>, TError,{data: CreateNoteRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createUserNote>>, TError,{data: CreateNoteRequest}, TContext> => {

const mutationKey = ['createUserNote'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUserNote>>, {data: CreateNoteRequest}> = (props) => {
          const {data} = props ?? {};

          return  createUserNote(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserNoteMutationResult = NonNullable<Awaited<ReturnType<typeof createUserNote>>>
    export type CreateUserNoteMutationBody = CreateNoteRequest
    export type CreateUserNoteMutationError = ErrorResponse | ErrorResponse

    /**
 * @summary Create new private note
 */
export const useCreateUserNote = <TError = ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUserNote>>, TError,{data: CreateNoteRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createUserNote>>,
        TError,
        {data: CreateNoteRequest},
        TContext
      > => {

      const mutationOptions = getCreateUserNoteMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Retrieve a specific private note by ID
 * @summary Get user's private note
 */
export const getGetUserNoteUrl = (id: string,) => {


  

  return `/me/notes/${id}`
}

export const getUserNote = async (id: string, options?: RequestInit): Promise<PrivateNoteResponse> => {
  
  return customFetch<PrivateNoteResponse>(getGetUserNoteUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetUserNoteQueryKey = (id?: string,) => {
    return [`/me/notes/${id}`] as const;
    }

    
export const getGetUserNoteQueryOptions = <TData = Awaited<ReturnType<typeof getUserNote>>, TError = ErrorResponse | ErrorResponse>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserNote>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserNoteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserNote>>> = ({ signal }) => getUserNote(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserNote>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserNoteQueryResult = NonNullable<Awaited<ReturnType<typeof getUserNote>>>
export type GetUserNoteQueryError = ErrorResponse | ErrorResponse


/**
 * @summary Get user's private note
 */

export function useGetUserNote<TData = Awaited<ReturnType<typeof getUserNote>>, TError = ErrorResponse | ErrorResponse>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserNote>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUserNoteQueryOptions(id,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing private note
 * @summary Update private note
 */
export const getUpdateUserNoteUrl = (id: string,) => {


  

  return `/me/notes/${id}`
}

export const updateUserNote = async (id: string,
    updateNoteRequest: UpdateNoteRequest, options?: RequestInit): Promise<PrivateNoteResponse> => {
  
  return customFetch<PrivateNoteResponse>(getUpdateUserNoteUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateNoteRequest,)
  }
);}




export const getUpdateUserNoteMutationOptions = <TError = ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserNote>>, TError,{id: string;data: UpdateNoteRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateUserNote>>, TError,{id: string;data: UpdateNoteRequest}, TContext> => {

const mutationKey = ['updateUserNote'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserNote>>, {id: string;data: UpdateNoteRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateUserNote(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserNoteMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserNote>>>
    export type UpdateUserNoteMutationBody = UpdateNoteRequest
    export type UpdateUserNoteMutationError = ErrorResponse | ErrorResponse | ErrorResponse

    /**
 * @summary Update private note
 */
export const useUpdateUserNote = <TError = ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserNote>>, TError,{id: string;data: UpdateNoteRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateUserNote>>,
        TError,
        {id: string;data: UpdateNoteRequest},
        TContext
      > => {

      const mutationOptions = getUpdateUserNoteMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Delete a private note from user's notebook
 * @summary Delete private note
 */
export const getDeleteUserNoteUrl = (id: string,) => {


  

  return `/me/notes/${id}`
}

export const deleteUserNote = async (id: string, options?: RequestInit): Promise<null> => {
  
  return customFetch<null>(getDeleteUserNoteUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteUserNoteMutationOptions = <TError = ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserNote>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUserNote>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteUserNote'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUserNote>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteUserNote(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserNoteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserNote>>>
    
    export type DeleteUserNoteMutationError = ErrorResponse | ErrorResponse

    /**
 * @summary Delete private note
 */
export const useDeleteUserNote = <TError = ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserNote>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteUserNote>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserNoteMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Get current user's profile information (regular users only).
Anonymous users will receive a 403 error.

 * @summary Get user profile
 */
export const getGetUserProfileUrl = () => {


  

  return `/me`
}

export const getUserProfile = async ( options?: RequestInit): Promise<UserProfileResponse> => {
  
  return customFetch<UserProfileResponse>(getGetUserProfileUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetUserProfileQueryKey = () => {
    return [`/me`] as const;
    }

    
export const getGetUserProfileQueryOptions = <TData = Awaited<ReturnType<typeof getUserProfile>>, TError = ErrorResponse | ErrorResponse>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserProfileQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserProfile>>> = ({ signal }) => getUserProfile({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserProfileQueryResult = NonNullable<Awaited<ReturnType<typeof getUserProfile>>>
export type GetUserProfileQueryError = ErrorResponse | ErrorResponse


/**
 * @summary Get user profile
 */

export function useGetUserProfile<TData = Awaited<ReturnType<typeof getUserProfile>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserProfile>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUserProfileQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update current user's profile information (regular users only).
Anonymous users will receive a 403 error.

 * @summary Update user profile
 */
export const getUpdateUserProfileUrl = () => {


  

  return `/me`
}

export const updateUserProfile = async (updateUserProfileRequest: UpdateUserProfileRequest, options?: RequestInit): Promise<UserProfileResponse> => {
  
  return customFetch<UserProfileResponse>(getUpdateUserProfileUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateUserProfileRequest,)
  }
);}




export const getUpdateUserProfileMutationOptions = <TError = ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserProfile>>, TError,{data: UpdateUserProfileRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateUserProfile>>, TError,{data: UpdateUserProfileRequest}, TContext> => {

const mutationKey = ['updateUserProfile'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserProfile>>, {data: UpdateUserProfileRequest}> = (props) => {
          const {data} = props ?? {};

          return  updateUserProfile(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserProfileMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserProfile>>>
    export type UpdateUserProfileMutationBody = UpdateUserProfileRequest
    export type UpdateUserProfileMutationError = ErrorResponse | ErrorResponse | ErrorResponse

    /**
 * @summary Update user profile
 */
export const useUpdateUserProfile = <TError = ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserProfile>>, TError,{data: UpdateUserProfileRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateUserProfile>>,
        TError,
        {data: UpdateUserProfileRequest},
        TContext
      > => {

      const mutationOptions = getUpdateUserProfileMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Exchange a Firebase anonymous ID token for a session cookie.

**Database Operation**: 
- If this is a new anonymous user, their data will be inserted into the database
- If this is an existing anonymous user, no database changes are made

**Use Cases**:
- First visit to My Notebook page
- Clicking "My Notebook" button from home page

 * @summary Anonymous user authentication
 */
export const getAuthenticateAnonymousUrl = () => {


  

  return `/auth/anonymous`
}

export const authenticateAnonymous = async (anonymousAuthRequest: AnonymousAuthRequest, options?: RequestInit): Promise<AuthResponse> => {
  
  return customFetch<AuthResponse>(getAuthenticateAnonymousUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      anonymousAuthRequest,)
  }
);}




export const getAuthenticateAnonymousMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticateAnonymous>>, TError,{data: AnonymousAuthRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof authenticateAnonymous>>, TError,{data: AnonymousAuthRequest}, TContext> => {

const mutationKey = ['authenticateAnonymous'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticateAnonymous>>, {data: AnonymousAuthRequest}> = (props) => {
          const {data} = props ?? {};

          return  authenticateAnonymous(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthenticateAnonymousMutationResult = NonNullable<Awaited<ReturnType<typeof authenticateAnonymous>>>
    export type AuthenticateAnonymousMutationBody = AnonymousAuthRequest
    export type AuthenticateAnonymousMutationError = ErrorResponse

    /**
 * @summary Anonymous user authentication
 */
export const useAuthenticateAnonymous = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticateAnonymous>>, TError,{data: AnonymousAuthRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof authenticateAnonymous>>,
        TError,
        {data: AnonymousAuthRequest},
        TContext
      > => {

      const mutationOptions = getAuthenticateAnonymousMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Exchange a Firebase regular user ID token for a session cookie.

**Database Operation**: 
- No database changes (user already exists)

**Use Cases**:
- Existing regular users logging in
- Email/password authentication

 * @summary Regular user login
 */
export const getLoginRegularUserUrl = () => {


  

  return `/auth/login`
}

export const loginRegularUser = async (loginRequest: LoginRequest, options?: RequestInit): Promise<AuthResponse> => {
  
  return customFetch<AuthResponse>(getLoginRegularUserUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginRequest,)
  }
);}




export const getLoginRegularUserMutationOptions = <TError = ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginRegularUser>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof loginRegularUser>>, TError,{data: LoginRequest}, TContext> => {

const mutationKey = ['loginRegularUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginRegularUser>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  loginRegularUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginRegularUserMutationResult = NonNullable<Awaited<ReturnType<typeof loginRegularUser>>>
    export type LoginRegularUserMutationBody = LoginRequest
    export type LoginRegularUserMutationError = ErrorResponse | ErrorResponse

    /**
 * @summary Regular user login
 */
export const useLoginRegularUser = <TError = ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginRegularUser>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof loginRegularUser>>,
        TError,
        {data: LoginRequest},
        TContext
      > => {

      const mutationOptions = getLoginRegularUserMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Exchange a Firebase new user ID token for a session cookie and create user profile.

**Database Operation**: 
- Insert new regular user data into the database

**Use Cases**:
- Brand new users creating regular accounts (not from anonymous)
- Direct signup without anonymous session

 * @summary New regular user registration
 */
export const getSignupNewUserUrl = () => {


  

  return `/auth/signup`
}

export const signupNewUser = async (signupRequest: SignupRequest, options?: RequestInit): Promise<AuthResponse> => {
  
  return customFetch<AuthResponse>(getSignupNewUserUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      signupRequest,)
  }
);}




export const getSignupNewUserMutationOptions = <TError = ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signupNewUser>>, TError,{data: SignupRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof signupNewUser>>, TError,{data: SignupRequest}, TContext> => {

const mutationKey = ['signupNewUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof signupNewUser>>, {data: SignupRequest}> = (props) => {
          const {data} = props ?? {};

          return  signupNewUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SignupNewUserMutationResult = NonNullable<Awaited<ReturnType<typeof signupNewUser>>>
    export type SignupNewUserMutationBody = SignupRequest
    export type SignupNewUserMutationError = ErrorResponse | ErrorResponse

    /**
 * @summary New regular user registration
 */
export const useSignupNewUser = <TError = ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signupNewUser>>, TError,{data: SignupRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof signupNewUser>>,
        TError,
        {data: SignupRequest},
        TContext
      > => {

      const mutationOptions = getSignupNewUserMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Convert an anonymous user to a regular user account using Firebase linkWithCredential.
This preserves the user's existing data while upgrading their account.

**Database Operation**: 
- Update existing anonymous user data in database (anonymous ‚Üí regular)
- Same UID is preserved, isAnonymous flag changes to false

**Use Cases**:
- Anonymous users upgrading to regular accounts
- Preserves all existing notes and data

 * @summary Promote anonymous user to regular account
 */
export const getPromoteAnonymousUserUrl = () => {


  

  return `/auth/promote`
}

export const promoteAnonymousUser = async (promoteRequest: PromoteRequest, options?: RequestInit): Promise<AuthResponse> => {
  
  return customFetch<AuthResponse>(getPromoteAnonymousUserUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      promoteRequest,)
  }
);}




export const getPromoteAnonymousUserMutationOptions = <TError = ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoteAnonymousUser>>, TError,{data: PromoteRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof promoteAnonymousUser>>, TError,{data: PromoteRequest}, TContext> => {

const mutationKey = ['promoteAnonymousUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof promoteAnonymousUser>>, {data: PromoteRequest}> = (props) => {
          const {data} = props ?? {};

          return  promoteAnonymousUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PromoteAnonymousUserMutationResult = NonNullable<Awaited<ReturnType<typeof promoteAnonymousUser>>>
    export type PromoteAnonymousUserMutationBody = PromoteRequest
    export type PromoteAnonymousUserMutationError = ErrorResponse | ErrorResponse | ErrorResponse

    /**
 * @summary Promote anonymous user to regular account
 */
export const usePromoteAnonymousUser = <TError = ErrorResponse | ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoteAnonymousUser>>, TError,{data: PromoteRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof promoteAnonymousUser>>,
        TError,
        {data: PromoteRequest},
        TContext
      > => {

      const mutationOptions = getPromoteAnonymousUserMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Logout and clear the session cookie. 
This does not affect the Firebase client-side authentication state.

**Database Operation**: 
- No database changes

 * @summary Clear session cookie
 */
export const getLogoutUrl = () => {


  

  return `/auth/logout`
}

export const logout = async ( options?: RequestInit): Promise<AuthResponse> => {
  
  return customFetch<AuthResponse>(getLogoutUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getLogoutMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext> => {

const mutationKey = ['logout'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
          

          return  logout(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    
    export type LogoutMutationError = ErrorResponse

    /**
 * @summary Clear session cookie
 */
export const useLogout = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof logout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getLogoutMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Verify the current session and return user information.
This endpoint also ensures the user exists in the database and will create 
an anonymous user record if needed.

**Database Operation**: 
- May insert anonymous user data if session exists but user not in DB

 * @summary Verify current session
 */
export const getVerifySessionUrl = () => {


  

  return `/auth/session`
}

export const verifySession = async ( options?: RequestInit): Promise<SessionResponse> => {
  
  return customFetch<SessionResponse>(getVerifySessionUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getVerifySessionQueryKey = () => {
    return [`/auth/session`] as const;
    }

    
export const getVerifySessionQueryOptions = <TData = Awaited<ReturnType<typeof verifySession>>, TError = ErrorResponse>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof verifySession>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getVerifySessionQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof verifySession>>> = ({ signal }) => verifySession({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof verifySession>>, TError, TData> & { queryKey: QueryKey }
}

export type VerifySessionQueryResult = NonNullable<Awaited<ReturnType<typeof verifySession>>>
export type VerifySessionQueryError = ErrorResponse


/**
 * @summary Verify current session
 */

export function useVerifySession<TData = Awaited<ReturnType<typeof verifySession>>, TError = ErrorResponse>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof verifySession>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getVerifySessionQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




